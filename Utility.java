import java.util.*;

public class Utility {

    /**
     * Calculate the Euclidean distance between two VRP nodes
     * @param node1 the first VRP node
     * @param node2 the second VRP node
     * @return the Euclidean distance between node1 and node2
     */
    public static double calculateEuclideanDistance(VRPNode node1, VRPNode node2) {
        double deltaX = node1.getX() - node2.getX();
        double deltaY = node1.getY() - node2.getY();
        return Math.sqrt(deltaX * deltaX + deltaY * deltaY);
    }

    /**
     * Calculate the total cost of a VRP solution under a VRP instance.
     * The total cost is the sum of all the Euclidean distance between adjacent nodes in the routes.
     * @param solution the VRP solution.
     * @param instance the VRP instance.
     * @return the total cost of the solution.
     */
    public static int calculateTotalCost(VRPSolution solution, VRPInstance instance) { // TODO: Implement the function to calculate the total cost of the solution.
        List<List<Integer>> routes = solution.getRoutes();
        double totalCost = 0;
        for(List<Integer> route : routes) {
            VRPNode node1 = instance.getNodes().get(route.get(0));

            for(int i = 1; i < route.size(); i++) {
                totalCost += calculateEuclideanDistance(node1, instance.getNodes().get(route.get(i)));
                node1 = instance.getNodes().get(route.get(i));
            }
        }
        return (int) totalCost;
    }

    /**
     * Generate a VRP solution for a VRP instance using the nearest neighbour heuristic.
     * @param instance the VRP instance.
     * @return the VRP solution generated by the nearest neighbour heuristic.
     */
    public static VRPSolution nearestNeighbourHeuristic(VRPInstance instance) { // TODO: Implement the nearest neighbour heuristic.
        Map<Integer, VRPNode> nodes = instance.getNodes();
        VRPNode depot = instance.getDepot();
        double vehicleCapacity = instance.getCapacity();
        List<List<Integer>> routes = new ArrayList<>();
        Set<Integer> visited = new HashSet<>();

        while(visited.size() < nodes.size() - 1) {
            List<Integer> route = new ArrayList<>();
            route.add(depot.getID());
            double currentCapacity = 0.0;
            VRPNode current = depot;

            while(true){
                VRPNode nearestNode = null;
                double nearestDistance = Double.MAX_VALUE;

                for(Map.Entry<Integer, VRPNode> entry : nodes.entrySet()) {
                    VRPNode node = entry.getValue();
                    if (!visited.contains(node.getID()) && node != depot && currentCapacity + node.getDemand() <= vehicleCapacity) {
                        double distance = calculateEuclideanDistance(current, node);
                        if (distance < nearestDistance) {
                            nearestDistance = distance;
                            nearestNode = node;
                        }
                    }
                }

                if (nearestNode == null) {
                    break; // No more nodes can be added to this route
                }

                route.add(nearestNode.getID());
                visited.add(nearestNode.getID());
                currentCapacity += nearestNode.getDemand();
                current = nearestNode;
            }

            route.add(depot.getID()); // Returning to depot
            routes.add(route);
        }

        return new VRPSolution(routes);
    }

    /**
     * Generate a VRP solution for a VRP instance using the savings heuristic.
     * @param instance the VRP instance.
     * @return the VRP solution generated by the savings heuristic.
     */
    public static VRPSolution savingsHeuristic(VRPInstance instance) {
        List<List<Integer>> routes = new ArrayList<>();

        for (VRPNode node : instance.getNodes().values()) {
            if (node.getID() == 1)
                continue;
            List<Integer> route = new ArrayList<>();
            route.add(node.getID());
            routes.add(route);
        }

        double[][] savings = new double[instance.getNodes().size() + 1][instance.getNodes().size() + 1];
        for (int i = 2; i < instance.getNodes().size(); i++) {
            for (int j = i + 1; j < instance.getNodes().size() + 1; j++) {
                VRPNode node1 = instance.getNodes().get(i);
                VRPNode node2 = instance.getNodes().get(j);
                savings[i][j] = calculateEuclideanDistance(node1, instance.getDepot())
                        + calculateEuclideanDistance(instance.getDepot(), node2) - calculateEuclideanDistance(node1, node2);
                savings[j][i] = savings[i][j];
            }
        }

        while (true) {
            List<Integer> bestMerge = merge(routes, savings, instance);
            if (bestMerge == null) {
                break;
            }
            //replaces existing routes with nodes in new merged route
            for (int i = routes.size() - 1; i >= 0; i--) { //in reverse to allow removal
                if (new HashSet<>(bestMerge).containsAll(routes.get(i))) {
                    routes.remove(i);
                }
            }
            routes.add(bestMerge);
        }

        //add the depot nodes to each end of the routes
        for(List<Integer> route : routes) {
            route.add(0,1);
            route.add(route.size(),1);
        }

        return new VRPSolution(routes);
    }

    private static List<Integer> merge(List<List<Integer>> routes, double[][] savings, VRPInstance instance) {
        double bestSaving = 0;
        List<Integer> bestMerge = null;
        for (List<Integer> route1 : routes) {
            for (List<Integer> route2 : routes) {
                if (route1 == route2) { continue; }

                double saving = savings[route1.get(route1.size()-1)][route2.get(0)];
                if (saving <= bestSaving) { continue; }

                List<Integer> merge = new ArrayList<>();
                merge.addAll(route1);
                merge.addAll(route2);

                double total = 0;
                for (int i : merge) {
                    total += instance.getNodes().get(i).getDemand();
                }
                if (total > instance.getCapacity()) { continue; }

                bestSaving = saving;
                bestMerge = merge;
            }
        }
        return bestMerge;
    }
}
